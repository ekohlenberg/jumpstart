using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Threading;
 
#pragma warning disable CS8604 // Possible null reference argument
#pragma warning disable CS8620 // Argument of type ... cannot be used for parameter of type ...
#pragma warning disable CS8618 // Non-nullable field is uninitialized

namespace @Model.Name 
{



    public class Proxy<T> : DispatchProxy 
    {   
        public T? Target { get; set; } 
        public string DomainObj { get; set; }
        
        // Static thread-safe collections for before/after actions
        private static readonly ConcurrentBag<Action<MethodInfo, object[]>> BeforeActions = new();
        private static readonly ConcurrentBag<Action<MethodInfo, object, object[]>> AfterActions = new();
        
        // Static flag to ensure Initialize is only called once per program session
        private static int _initialized = 0;
        private static readonly object _initializeLock = new object();

        /// <summary>
        /// Gets the list of before actions (thread-safe)
        /// </summary>
        public static IEnumerable<Action<MethodInfo, object[]>> GetBeforeActions()
        {
            return BeforeActions;
        }

        /// <summary>
        /// Gets the list of after actions (thread-safe)
        /// </summary>
        public static IEnumerable<Action<MethodInfo, object, object[]>> GetAfterActions()
        {
            return AfterActions;
        }

        /// <summary>
        /// Adds a before action to be executed before method invocation (thread-safe, static)
        /// </summary>
        public static void AddBeforeAction(Action<MethodInfo, object[]> action)
        {
            if (action == null) throw new ArgumentNullException(nameof(action));
            BeforeActions.Add(action);
        }

        /// <summary>
        /// Adds an after action to be executed after method invocation (thread-safe, static)
        /// </summary>
        public static void AddAfterAction(Action<MethodInfo, object, object[]> action)
        {
            if (action == null) throw new ArgumentNullException(nameof(action));
            AfterActions.Add(action);
        }

        
        protected override object? Invoke(MethodInfo? targetMethod, object?[]? args)
        {
            if (targetMethod == null) return null;

            // Iterate over thread-safe collection
            foreach (var action in BeforeActions)
            {
               if (action != null) action.Invoke(targetMethod, args);
            }

            var result = targetMethod.Invoke(Target, args);

            // Iterate over thread-safe collection
            foreach (var action in AfterActions)
            {
                if (action != null) action.Invoke(targetMethod, result, args);
            }


            return result;
        }

        /// <summary>
        /// Initializes the proxy with default before/after actions.
        /// This method is guaranteed to execute only once per program session (thread-safe).
        /// </summary>
        public virtual void Initialize()
        {
            // Use Interlocked to ensure only one thread can set the flag
            if (Interlocked.CompareExchange(ref _initialized, 1, 0) != 0)
            {
                // Already initialized, return immediately
                return;
            }

            // Double-check lock pattern for additional safety
            lock (_initializeLock)
            {
                // Check again inside lock to be absolutely sure
                if (_initialized == 2)
                {
                    return;
                }

                // Perform initialization
                AddBeforeAction((method, args) =>
                {
                    // Log the method name and arguments
                    Logger.Info($"Invoking {DomainObj}.{method.Name}."/* with arguments: {string.Join(", ", args)}"*/);
                });

                AddBeforeAction((method, args) =>
                {
                    // Log the method name and arguments
                    

                    Logger.Debug($"Checking {Environment.UserName} authorization for {DomainObj}.{method.Name}."/*" with arguments: {string.Join(", ", args)}"*/);

                    bool authorized = OpRoleMemberLogic.Authorized( DomainObj, method.Name );

                    if (authorized)
                    {
                        Logger.Debug($"{Environment.UserName} is authorized for {DomainObj}.{method.Name}."/* with arguments: {string.Join(", ", args)}"*/);
                    } 
                    else
                    { 
                        throw new Exception($"Principal {Environment.UserName} is not authorized for {DomainObj}.{method.Name}.");
                    }

                });

                

                AddBeforeAction((method, args) =>
                {
                    // Log the method name and arguments
                    Logger.Info($"invoking pre event service for {DomainObj}.{method.Name}." /*with arguments: {string.Join(", ", args)}"*/);

                    EventContext ctx = new EventContext("post", DomainObj, method.Name, args);
                    EventServiceLogic.Invoke( ctx ); 

                    if (ctx.ScriptException != null) throw new Exception( $"Error in pre {DomainObj}.{method.Name} event", ctx.ScriptException);
                    
                });


                AddAfterAction((method, result, args) =>
                {
                    // Log the method name and arguments
                    Logger.Info($"After invoking {method.Name}."/* with arguments: {string.Join(", ", args)}"*/);
                });

                AddAfterAction((method, result, args) =>
                {
                    // Log the method name and arguments
                    Logger.Info($"invoking post event service for or {DomainObj}.{method.Name}." /* with arguments: {string.Join(", ", args)}"*/);

                    EventContext ctx = new EventContext("post", DomainObj, method.Name, args, result);
                    EventServiceLogic.Invoke( ctx ); 
                   
                    if (ctx.ScriptException != null) throw new Exception( $"Error in post {DomainObj}.{method.Name} event", ctx.ScriptException);
                });
                
                // Mark as fully initialized
                Interlocked.Exchange(ref _initialized, 2);
            }
        }
      

    }


}
#pragma warning restore CS8604 // Possible null reference argument
#pragma warning restore CS8620 // Argument of type ... cannot be used for parameter of type ...
#pragma warning restore CS8618 // Non-nullable field is uninitialized
